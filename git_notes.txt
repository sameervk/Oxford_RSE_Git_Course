1). Central repositories should always be created as bare repositories because pushing branches to a non-bare repository has the potential to overwrite changes. Think of --bare as a way to mark a repository as a storage facility, as opposed to a development environment. This means that for virtually all Git workflows, the central repository is bare, and developers local repositories are non-bare.

2). Cloning automatically creates a remote connection called "origin" pointing back to the original repository. This makes it very easy to interact with a central repository. 

3). git clone -depth=1 <repo>

Shallow clone: clone of <repo> is made and only the most recent commit is included in the new cloned Repo. Shallow cloning is most useful when working with repos that have an extensive commit history. 

4). As in any revision control system, it’s important to create atomic commits so that it’s easy to track down bugs and revert changes with minimal impact on the rest of the project.

5). git add -p

Begin an interactive staging session that lets you choose portions of a file to add to the next commit. This will present you with a chunk of changes and prompt you for a command. Use y to stage the chunk, n to ignore the chunk, s to split it into smaller chunks, e to manually edit the chunk, and q to exit.

6). git add .
	git commit

To create an initial commit of the current directory

7) git commit --amend

This option adds another level of functionality to the commit command. Passing this option will modify the last commit. Instead of creating a new commit, staged changes will be added to the previous commit. 

8) Git doesn't require commit messages to follow any specific formatting constraints, but the canonical format is to summarize the entire commit on the first line in less than 50 characters, leave a blank line, then a detailed explanation of what’s been changed. For example:

--
Change the message displayed by hello.py

- Update the sayHello() function to output the user's name
- Change the sayGoodbye() function to a friendlier message
--

It is a common practice to use the first line of the commit message as a subject line, similar to an email. The rest of the log message is considered the body and used to communicate details of the commit change set. Note that many developers also like to use the present tense in their commit messages. This makes them read more like actions on the repository, which makes many of the history-rewriting operations more intuitive.

9) git diff --cached ./path/to/file

When git diff is invoked with the --cached option the diff will compare the staged changes with the local repository. The --cached option is synonymous with --staged.

10) git diff branch1..other-feature-branch

This example introduces the dot operator. The two dots in this example indicate the diff input is the tips of both branches. The same effect happens if the dots are omitted and a space is used between the branches.

11) git diff master new_branch ./diff_test.txt

To compare a specific file across branches, pass in the path of the file as the third argument to git diff

12) Stashing is handy if you need to quickly switch context and work on something else, but you're mid-way through a code change and aren't quite ready to commit. Note that the stash is local to your Git repository; stashes are not transferred to the server when you push.

13) git stash apply

You can reapply the changes to your working copy and keep them in your stash with git stash apply. This is useful if you want to apply the same stashed changes to multiple branches. By default Git won't stash changes made to untracked or ignored files.

14) git stash pop
Popping your stash removes the changes from your stash and reapplies them to your working copy. By default, git stash pop will re-apply the most recently created stash: stash@{0}
You can choose which stash to re-apply by passing its identifier as the last argument.

15) Adding the -u option (or --include-untracked) tells git stash to also stash your untracked files. You can include changes to ignored files as well by passing the -a option (or --all) when running git stash.

16) To provide a bit more context, it's good practice to annotate your stashes with a description, using git stash save "message"

17) git stash show -p

You can view a summary of a stash with git stash show or pass the -p option (or --patch) to view the full diff of a stash.

18) If the changes on your branch diverge from the changes in your stash, you may run into conflicts when popping or applying your stash. Instead, you can use git stash branch to create a new branch to apply your stashed changes to:

19) If you decide you no longer need a particular stash, you can delete it with git stash drop/clear


20) $ echo debug.log >> .gitignore
 
	$ git rm --cached debug.log
	rm 'debug.log'
 
	$ git commit -m "Start ignoring debug.log"

If you want to ignore a file that you've committed in the past, you'll need to delete the file from your repository and then add a .gitignore rule for it. Using the --cached option with git rm means that the file will be deleted from your repository, but will remain in your working directory as an ignored file. You can omit the --cached option if you want to delete the file from both the repository and your local file system.


21) $ cat .gitignore
	*.log
 
	$ git add -f debug.log
 
	$ git commit -m "Force adding debug.log"

It is possible to force an ignored file to be committed to the repository using the -f (or --force) option with git add. 
However a better solution is to define an exception to the general rule:

$ echo !debug.log >> .gitignore
 
$ cat .gitignore
*.log
!debug.log
 
$ git add debug.log
 
$ git commit -m "Adding debug.log"

This approach is more obvious, and less confusing, for your teammates.


22) $ git check-ignore -v debug.log
.gitignore:3:*.log debug.log 

If you have complicated .gitignore patterns, or patterns spread over multiple .gitignore files, it can be difficult to track down why a particular file is being ignored. You can use the git check-ignore command with the -v (or --verbose) option to determine which pattern is causing a particular file to be ignored:


